# 実行計画 (ExecPlan)

このドキュメントでは、コーディングエージェントが機能またはシステム変更を実現するために従う設計ドキュメントである実行計画（以下「ExecPlan」）の要件について説明します。読者はこのリポジトリについて全くの初心者であると仮定してください。彼らが持っているのは、現在の作業ツリーとあなたが提供する単一のExecPlanファイルだけです。以前の計画の記憶や、外部のコンテキストは一切ありません。

## ExecPlanとPLANS.mdの利用方法

実行可能な仕様（ExecPlan）を作成する際は、PLANS.mdに**厳密に**従ってください。もしコンテキストに含まれていない場合は、PLANS.mdファイルをすべて読んで記憶を更新してください。正確な仕様を作成するために、ソース資料を徹底的に読み（そして読み返し）てください。仕様を作成する際は、骨子から始めて、調査を進めるにつれて肉付けしていきましょう。

実行可能な仕様（ExecPlan）を実装する際は、ユーザーに「次のステップ」を尋ねるのではなく、次のマイルストーンにそのまま進んでください。すべてのセクションを最新の状態に保ち、停止するたびにリストのエントリを追加または分割して、達成された進捗と次のステップを明確に述べましょう。曖昧な点は自律的に解決し、頻繁にコミットしてください。

実行可能な仕様（ExecPlan）について議論する際は、決定事項を後世のために仕様内のログに記録してください。仕様への変更がなぜ行われたのかは、明確に理解できる必要があります。ExecPlanは生きたドキュメントであり、**常に**ExecPlanのみから作業を再開できる必要があります。

困難な要件や重大な未知の要素を伴う設計を研究する際は、マイルストーンを利用して概念実証や「おもちゃの実装」などを行い、ユーザーの提案が実現可能かどうかを検証できるようにしましょう。ライブラリのソースコードを見つけたり入手したりして読み込み、深く調査し、より完全な実装を導くためのプロトタイプを含めてください。

## 要件

**譲歩できない要件:**

*   すべてのExecPlanは完全に自己完結的でなければなりません。自己完結的とは、その現在の形式で、初心者が成功するために必要なすべての知識と指示を含んでいることを意味します。
*   すべてのExecPlanは生きたドキュメントです。貢献者は、進捗状況、発見、設計決定が確定するにつれて、これを改訂する必要があります。各改訂は完全に自己完結的なままでなければなりません。
*   すべてのExecPlanは、このリポジトリに関する事前の知識がなくても、完全な初心者が機能を最初から最後まで実装できるようにする必要があります。
*   すべてのExecPlanは、単に「定義を満たす」ためのコード変更だけでなく、実証可能に機能する動作を生成する必要があります。
*   すべてのExecPlanは、専門用語を平易な言葉で定義するか、使用しないかのいずれかでなければなりません。

目的と意図が最優先されます。まず、ユーザーの視点から、なぜこの作業が重要なのかを数文で説明してください。この変更の後、誰が何ができるようになるのか、そしてそれがどのように機能するのかを示してください。次に、何を編集し、何を実行し、何を観察すべきかを含め、その結果を達成するための正確な手順を読者に案内してください。

あなたの計画を実行するエージェントは、ファイルをリスト表示し、ファイルを読み込み、検索し、プロジェクトを実行し、テストを実行できます。以前のコンテキストを知らず、以前のマイルストーンからあなたが何を意味したかを推測することはできません。依存する仮定はすべて繰り返してください。外部のブログやドキュメントを参照しないでください。知識が必要な場合は、あなた自身の言葉で計画自体に埋め込んでください。ExecPlanが以前のExecPlanに基づいて構築されており、そのファイルがチェックインされている場合は、参照として組み込んでください。そうでない場合は、その計画からのすべての関連コンテキストを含める必要があります。

## フォーマット

フォーマットと構成はシンプルかつ厳格です。各ExecPlanは、トリプルバックティックで始まりトリプルバックティックで終わる、`md`とラベル付けされた単一のフェンスで囲まれたコードブロックでなければなりません。追加のトリプルバックティックコードフェンスをネストしないでください。コマンド、トランスクリプト、差分、またはコードを表示する必要がある場合は、その単一のフェンス内でインデントされたブロックとして提示してください。ExecPlanのコードフェンスが prematurely 閉じられるのを避けるため、コードフェンスの代わりにインデントを使って明瞭にしてください。各見出しの後には2つの改行を入れ、#、##などを使用し、順序付きリストおよび順序なしリストには正しい構文を使用してください。

ファイルの内容が単一のExecPlan**のみ**であるMarkdown (.md) ファイルにExecPlanを記述する場合、トリプルバックティックは省略すべきです。

平易な散文で記述してください。リストよりも文章を優先してください。簡潔さが意味を不明瞭にする場合を除き、チェックリスト、表、長い列挙は避けてください。チェックリストは、必須である`Progress`セクションでのみ許可されます。物語のセクションは、散文を第一とする必要があります。

## ガイドライン

自己完結性と平易な言葉が最も重要です。一般的な英語ではないフレーズ（「デーモン」、「ミドルウェア」、「RPCゲートウェイ」、「フィルターグラフ」）を導入する場合は、すぐにそれを定義し、このリポジトリでどのように現れるか（例えば、それが現れるファイル名やコマンド名を挙げることによって）を読者に思い出させてください。
「以前に定義されているように」や「アーキテクチャドキュメントによると」などとは言わないでください。繰り返しの説明になったとしても、必要な説明はここに含めてください。

一般的な失敗モードを避けてください。未定義の専門用語に頼らないでください。結果としてコードがコンパイルされても意味のあることを何もしないほど、「機能の字面」を狭く記述しないでください。主要な決定を読者に委ねないでください。曖昧さがある場合は、計画自体でそれを解決し、そのパスを選択した理由を説明してください。ユーザーに見える効果については過剰に説明し、付随的な実装の詳細については過小に説明する傾向にあります。

計画を観測可能な結果と結びつけてください。実装後にユーザーができること、実行するコマンド、そして彼らが見るべき出力について述べてください。受け入れは、人間が検証できる行動として表現されるべきです（「サーバー起動後、[http://localhost:8080/health](http://localhost:8080/health)にアクセスすると、HTTP 200とボディOKが返される」）というように、内部属性（「HealthCheck構造体を追加した」）ではありません。変更が内部的なものである場合でも、その影響がどのように実証できるかを説明してください（例えば、変更前には失敗し、変更後には成功するテストを実行することや、新しい動作を使用するシナリオを示すことによって）。

リポジトリのコンテキストを明示的に指定してください。ファイルはリポジトリのルートからのフルパスで命名し、関数やモジュールは正確に命名し、新しいファイルがどこに作成されるべきかを記述してください。複数の領域にまたがる場合は、それらの部分がどのように連携するかを説明する短い導入段落を含めて、初心者が自信を持ってナビゲートできるようにしてください。コマンドを実行する際は、作業ディレクトリと正確なコマンドラインを示してください。結果が環境に依存する場合は、仮定を述べ、合理的な場合は代替手段を提供してください。

冪等性と安全性を確保してください。手順は、損傷やずれを引き起こすことなく複数回実行できるように記述してください。手順が途中で失敗する可能性がある場合は、再試行または適応する方法を含めてください。移行や破壊的な操作が必要な場合は、バックアップまたは安全なフォールバックを詳しく説明してください。進行中に検証できる、追加的でテスト可能な変更を優先してください。

検証は必須です。テストの実行、該当する場合はシステムの起動、およびそれが有用なことを行う様子を観察するための指示を含めてください。新しい機能や能力については、包括的なテストを記述してください。初心者が成功と失敗を区別できるように、期待される出力とエラーメッセージを含めてください。可能であれば、コンパイルを超えて変更が有効であることを証明する方法を示してください（例えば、小規模なエンドツーエンドシナリオ、CLI呼び出し、またはHTTPリクエスト/レスポンスのトランスクリプトを通じて）。プロジェクトのツールチェーンに適した正確なテストコマンドと、その結果を解釈する方法を述べてください。

証拠を記録してください。手順がターミナル出力、短い差分、またはログを生成する場合、それらを単一のフェンスブロック内にインデントされた例として含めてください。簡潔に保ち、成功を証明することに焦点を当ててください。パッチを含める必要がある場合は、読者があなたの指示に従って再作成できるような、ファイルスコープの差分または小さな抜粋を優先し、大きな塊を貼り付けないでください。

## マイルストーン

マイルストーンは物語であり、官僚的なものではありません。作業をマイルストーンに分割する場合は、それぞれのマイルストーンを、スコープ、以前には存在しなかったがマイルストーンの終わりに存在するようになるもの、実行するコマンド、そして期待する受け入れ行動を簡潔な段落で説明して導入してください。物語として読みやすいようにしてください：目標、作業、結果、証明。進捗とマイルストーンは別物です。マイルストーンは物語を語り、進捗は詳細な作業を追跡します。どちらも存在する必要があります。単に簡潔にするためだけにマイルストーンを省略したり、将来の実装にとって重要になる可能性のある詳細を省略したりしないでください。

各マイルストーンは、個別に検証可能であり、実行計画の全体的な目標を段階的に実装する必要があります。

## 生きた計画と設計上の決定

*   ExecPlanは生きたドキュメントです。主要な設計決定を下したら、その決定と背後にある考え方の両方を記録するように計画を更新してください。すべての決定は「決定ログ」セクションに記録してください。
*   ExecPlanには、「進捗」セクション、「驚きと発見」セクション、「決定ログ」セクション、および「結果と反省」セクションが含まれ、維持されている必要があります。これらはオプションではありません。
*   オプティマイザの動作、パフォーマンスのトレードオフ、予期しないバグ、またはアプローチを形成した逆/適用解除のセマンティクスを発見した場合は、それらの観察結果を「驚きと発見」セクションに短い証拠スニペット（テスト出力が理想的）とともに記録してください。
*   実装途中で方針を変更した場合は、その理由を「決定ログ」に文書化し、その影響を「進捗」に反映させてください。計画は、次の貢献者へのガイドであると同時に、あなた自身のためのチェックリストでもあります。
*   主要なタスクまたは計画全体の完了時に、達成されたこと、残っていること、および学んだ教訓を要約する「結果と反省」エントリを記述してください。

# プロトタイピングのマイルストーンと並行実装

より大規模な変更のリスクを低減する明示的なプロトタイピングマイルストーンを含めることは許容され、しばしば推奨されます。例としては、実現可能性を検証するために依存関係に低レベルの演算子を追加したり、オプティマイザの効果を測定しながら2つの構成順序を検討したりすることが挙げられます。プロトタイプは追加的でテスト可能に保ってください。スコープを「プロトタイピング」と明確に表示し、実行方法と結果の観察方法、およびプロトタイプを昇格または破棄する基準を記述してください。

テストを合格に保つ追加的なコード変更の後に削除を行うことを優先してください。並行実装（例えば、移行中にアダプターを古いパスと一緒に保持すること）は、リスクを軽減したり、大規模な移行中にテストを合格し続けさせたりする場合に有効です。両方のパスを検証する方法と、テストを使用して1つを安全に廃止する方法を記述してください。複数の新しいライブラリや機能領域を扱う場合は、これらの機能の実現可能性を**互いに独立して**評価するスパイクを作成することを検討し、外部ライブラリが期待どおりに動作し、必要な機能を単独で実装することを確認してください。

## 優れたExecPlanの骨子

```md
# <短く、行動指向の記述>

このExecPlanは生きたドキュメントです。「進捗」、「驚きと発見」、「決定ログ」、および「結果と反省」のセクションは、作業が進むにつれて常に最新の状態に保つ必要があります。

PLANS.mdファイルがリポジトリにチェックインされている場合は、リポジトリのルートからそのファイルへのパスをここに参照し、このドキュメントがPLANS.mdに従って維持されなければならないことを明記してください。

## 目的 / 全体像

この変更によって何が得られ、どのように機能するのかを、ユーザーの視点から数文で説明してください。有効になるユーザーに見える振る舞いを述べてください。

## 進捗

チェックボックス付きのリストを使用して、詳細な手順を要約してください。すべての停止ポイントはここに文書化される必要があります。これには、部分的に完了したタスクを「完了済み」と「未完了」の2つに分割する必要がある場合も含まれます。このセクションは常に作業の実際の現在の状態を反映する必要があります。

- [x] (2025-10-01 13:00Z) 完了したステップの例。
- [ ] 未完了のステップの例。
- [ ] 部分的に完了したステップの例（完了: X; 残り: Y）。

タイムスタンプを使用して進捗率を測定してください。

## 驚きと発見

実装中に発見された予期せぬ動作、バグ、最適化、または洞察を文書化してください。簡潔な証拠を提供してください。

- 観察: ...
  証拠: ...

## 決定ログ

計画作業中に行われたすべての決定を次の形式で記録してください。

- 決定: ...
  根拠: ...
  日付/著者: ...

## 結果と反省

主要なマイルストーンまたは完了時に、結果、不足点、学んだ教訓を要約してください。結果を元の目的と比較してください。

## コンテキストと概要

読者が何も知らないかのように、このタスクに関連する現在の状況を説明してください。主要なファイルとモジュールをフルパスで命名してください。使用する明白でない用語をすべて定義してください。以前の計画を参照しないでください。

## 作業計画

編集と追加の順序を散文で記述してください。各編集について、ファイル名と場所（関数、モジュール）を記述し、何を挿入または変更するかを述べてください。具体的かつ最小限に保ってください。

## 具体的な手順

実行する正確なコマンドと、それらを実行する場所（作業ディレクトリ）を述べてください。コマンドが何らかの出力を生成する場合、読者が比較できるように短い期待されるトランスクリプトを示してください。このセクションは作業が進むにつれて更新される必要があります。

## 検証と受け入れ

システムの起動方法や動作確認方法、および観察すべき内容を記述してください。受け入れは、特定の入力と出力を持つ動作として表現してください。テストが関係する場合、「<プロジェクトのテストコマンド>を実行し、<N>個が合格することを期待する。新しいテスト<名前>は変更前には失敗し、変更後には成功する」と述べてください。

## 冪等性と復旧

手順を安全に繰り返せる場合は、その旨を述べてください。手順にリスクがある場合は、安全な再試行またはロールバックパスを提供してください。完了後は環境をきれいに保ってください。

## アーティファクトとメモ

最も重要なトランスクリプト、差分、またはスニペットをインデントされた例として含めてください。簡潔に保ち、成功を証明することに焦点を当ててください。

## インターフェースと依存関係

規範的に記述してください。使用するライブラリ、モジュール、サービスの名前とその理由を述べてください。マイルストーンの終わりに存在しなければならない型、トレイト/インターフェース、および関数シグネチャを指定してください。`crate::module::function`や`package.submodule.Interface`のような安定した名前とパスを優先してください。例：

crates/foo/planner.rs に以下を定義します：

    pub trait Planner {
        fn plan(&self, observed: &Observed) -> Vec<Action>;
    }
```

上記のガイダンスに従えば、単一のステートレスなエージェント、あるいは人間の初心者があなたのExecPlanを上から下まで読み込み、機能する、観測可能な結果を生み出すことができます。それが基準です：自己完結的、自給自足、初心者向け、結果重視。

計画を改訂する際は、変更がリビングドキュメントのセクションを含むすべてのセクションに包括的に反映されていることを確認する必要があり、計画の最後に変更とその理由を説明するメモを記述する必要があります。ExecPlanは、ほとんどすべてについて「何を」だけでなく「なぜ」も説明する必要があります。